---
tags: b-tree, data-structure
---
![Untitled](Untitled%2098.png)

B-트리는 **대용량 데이터의 저장 및 검색에 최적화된 균형 트리 데이터 구조**의 일종입니다.

B-트리는 파일 시스템과 데이터베이스에서 **대량의 데이터를 색인화하기 위해 자주 사용**됩니다.

**트리의 키 수가 증가하더라도 균형 잡힌 트리 구조를 유지**할 수 있는 기능이 있습니다.

데이터가 디스크에 저장되는 방식을 이해하면 B- 트리의 사용 사례에 대해 이해할 수 있으니 아래 간략하게 서술합니다.

> **기존 하드 디스크 드라이브(HDD)의 블록 크기는 일반적으로 512바이트인 반면,** 솔리드 스테이트 드라이브(SSD)에서는 블록 크기가 4KB, 8KB, 심지어 16KB까지 다양할 수 있습니다.
> 

# 예제로 이해하기

![다음 Empolyee 테이블이 존재할 때](Untitled%2099.png)

다음 Empolyee 테이블이 존재할 때

```bash
EMP_Id - > 20 bytes
EMP_NAME - > 50 bytes
EMP_GENDER - > 4 bytes
EMP_ROLE - > 8 bytes
EMP_AGE - > 10 bytes
EMP_PHONE - > 10 bytes
EMP_EXPERIENCE - > 10 bytes
EMP_DEPT - > 8 bytes

Total bytes we need to store 1 record -> 120 bytes for single employee
```

데이터베이스에 단일 직원 세부 정보를 저장하려면 120바이트의 저장 공간이 필요합니다. 

블록 크기가 512바이트라는 것을 알고 있으므로 이에 따라 단일 스토리지인덱싱

<aside>
💡 레코드 수 = 블록 크기 / 레코드 크기

</aside>

블록 1에 1~4번 레코드를 저장하고 블록 2에 5~8번 레코드를 저장할 수 있습니다.

![Untitled](Untitled%20100.png)

직원이 10,000명이라고 가정하면, 이 양의 데이터를 저장하려면 2,500개의 블록(하나의 블록에 직원 4명을 저장할 수 있음)이 필요합니다.

데이터베이스에서 레코드를 가져오려면 이 2500개의 블록을 모두 파싱하여 데이터베이스에서 특정 레코드를 가져와야 한다고 가정해 보겠습니다.

이것은 성능에 큰 문제를 야기합니다.

어떻게 해결할 수 있을까요? 데이터베이스 위에 인덱스를 추가하여 필요한 레코드를 디스크에서 가져오는 가져오기 쿼리를 개선할 수 있습니다.

## 인덱싱이 어떻게 이 문제를 해결하나?

인덱싱하지 않고 엠피아이디에서 직원 세부 정보를 가져오려면 각 블록을 살펴보고 `emp_id`를 일치시켜 데이터를 가져와야 한다고 가정했을 때, 인덱싱을 사용하면 `emp_id` 키에 인덱스를 생성하여 빠르게 검색할 수 있습니다.

![인덱스 또한 디스크에 저장된다.](Untitled%20101.png)

인덱스 또한 디스크에 저장된다.

인덱스도 결국 디스크에 저장되며 `emp_id` 와 디스크의 실제 레코드에 대한 포인터만 있는 전용 인덱스 테이블을 생성합니다.

그리고 이 인덱스 테이블은 `emp_table` 테이블에서 조회하는 것에 비해 빠릅니다.

인덱스를 저장하기 위해 얼마나 많은 공간을 확보해야 하는 지 봅시다.

```bash
EMP_Id - > 20 bytes
POINTER - > 6 bytes

Total bytes we need to store 1 entry -> 26 bytes

No. of records to be              =   Block size / Record size
stored in block

we can store  = 512/26 = 19 records
```

단일 블록에 19개의 레코드를 저장할 수 있으며, 10,000개의 레코드를 저장하려면 526개의 블록을 사용해야 합니다.

> 이제 데이터베이스에서 레코드를 찾으려면 526개 블록만 검색하면 됩니다. 
**2500개 블록에서 526개 블록으로 줄였습니다.**
> 

<aside>
💡 이것은 하나의 인덱스일 뿐이며, 다른 인덱스 위에 인덱스를 추가하여 검색 성능을 향상시킬 수 있는데, 이를 **다단계 인덱스(multi-level index)**라고 합니다.

</aside>

대부분의 데이터베이스에서 B-tree 자료구조를 사용하며 이것은 레코드에 빠르게 접근할 수 있게 해줍니다.

<aside>
💡 MongoDB 도 인덱싱에 B-Tree 구조를 사용합니다.

</aside>

<aside>
💡 B-tree 의 최악의 시간 복잡도는 O(log n) 입니다.

</aside>

# B-Tree 작동 원리

데이터를 노드라고 하는 관리하기 쉬운 작은 블록으로 나누는 방식으로 작동합니다. 

각 노드에는 **고정된 수의 키와 하위 노드에 대한 포인터**가 포함됩니다.

정수를 저장하는 B-트리가 있고 최소 차수 't'가 3이라고 가정해 보겠습니다. 

트리의 각 노드는 최소 3-1=2 개의 키와 3개의 자식을 포함할 수 있습니다.

이진 트리에서 알다시피 자식은 최대 2개이며 각 노드는 단일 값을 포함할 수 있습니다.

### 이진 트리 속성은 다음과 같습니다

- 왼쪽 노드는 부모보다 작고 오른쪽 노드는 부모보다 큽니다.
- 각 노드는 최대 2개의 자식을 가질 수 있습니다.
    
    ![이진 트리 (Binary Tree)](Untitled%20102.png)
    
    이진 트리 (Binary Tree)
    
    B-tree에서 각 노드는 여러 개의 키를 가질 수 있습니다.
    

**B-Tree 에서 각 노드의 모습은 다음과 같습니다.**

![Untitled](Untitled%20103.png)

<aside>
💡 각 노드에는 키, 레코드 포인터(디스크의 실제 레코드를 가리킴), 자식 포인터라고도 하는 블록 포인터(자식 노드를 가리킴)가 있습니다.

</aside>

보시다시피 노드에 여러 개의 키를 가질 수 있습니다. 

키의 개수는 루트 노드가 아닌 노드가 가질 수 있는 **최소 키 개수인 최소 차수 "t"**를 사용하여 정의할 수 있습니다. 

즉, B-Tree는 **루트 노드가 아닌 각 노드에 대해 최소 t-1개의 키와 t개의 자식을 가질 수 있습니다.**

<aside>
💡 위 다이어그램에서 최소 차수는 4이며, 이는 3개의 키와 4개의 자식을 가질 수 있음을 의미합니다.

</aside>

## **B-Tree 만족 조건**

- 루트 노드는 최소 2개의 자식을 가질 수 있습니다.
- 모든 리프 노드는 같은 레벨에 있어야 합니다.
- 각 노드에는 `t / 2개`의 자식이 있어야 합니다(t는 최소 차수)

## B-Tree 생성 예시

최소 차수가 4일 때의 B-Tree 의 생성 예시를 다루어 보겠습니다.

```bash
keys = 10,20,40,50,65,80,90,25,30
```

알다시피 각 노드에는 키 1개와 자식 1개가 있을 수 있습니다. 

따라서 노드에 3개의 키와 4개의 자식 포인터를 저장할 수 있습니다.

노드에 10, 20, 40을 차례로 추가해보겠습니다.

![키 제한(예: 3)에 도달할 때까지 10 , 20 , 30을 차례로 추가합니다.](Untitled%20104.png)

키 제한(예: 3)에 도달할 때까지 10 , 20 , 30을 차례로 추가합니다.

### 50 추가하기

이제 50개를 추가해야 하지만 키 제한(즉, 3)에 도달했습니다. 

따라서 이 시점에서 분할해야 합니다.

다른 노드를 생성하고 현재 노드를 분할하여 노드 간의 균형을 맞추고 루트를 승격해야 합니다.

![Untitled](Untitled%20105.png)

### 65 추가하기

65라는 키를 하나 더 추가해 봅시다. 65는 40보다 크므로 오른쪽 노드에 사용 가능한 공간이 있는지 확인해야 하는데, 오른쪽 노드에는 키(50)가 1개만 있으므로 여기에 65를 추가하면 됩니다.

![Untitled](Untitled%20106.png)

### 80 추가하기

![새 키를 위한 공간이 확보됨에 따라 40의 오른쪽에 80 키를 추가했습니다.](Untitled%20107.png)

새 키를 위한 공간이 확보됨에 따라 40의 오른쪽에 80 키를 추가했습니다.

### 90 추가하기

여기서 루트 오른쪽 노드에 90개를 추가하려고 할 때 한계에 도달하여 더 이상 키를 추가할 수 없으므로 노드를 분할하고 새 노드를 만들어야 합니다.

![80은 루트로 승격되고 공간이 있으면 루트에서 병합되며 90은 새 노드를 생성합니다.](Untitled%20108.png)

80은 루트로 승격되고 공간이 있으면 루트에서 병합되며 90은 새 노드를 생성합니다.

### 25 추가하기

25는 40보다 작으므로 루트 노드의 왼쪽에 추가해야 하며 왼쪽 노드에는 키를 하나 더 넣을 공간이 있으므로 25를 추가할 수 있습니다.

![Untitled](Untitled%20109.png)

### 30 추가하기

30은 루트보다 작으므로 루트의 왼쪽 노드에 추가해야 하지만 왼쪽 노드도 키 3개라는 한계에 도달했기 때문에 노드를 분할하고 루트를 승격하여 새 노드를 생성해야 합니다.

![25는 루트로 승격되며, 루트에는 새 키를 위한 공간이 있으므로 루트에 추가되고 30은 새 노드를 생성합니다.](Untitled%20110.png)

25는 루트로 승격되며, 루트에는 새 키를 위한 공간이 있으므로 루트에 추가되고 30은 새 노드를 생성합니다.

이것이 B-Tree 의 구축이 이루어지는 방식입니다.

B-트리에 쿼리를 수행하면 이진 검색 트리와 유사한 방식으로 트리에서 요청된 데이터를 검색합니다. 

이 프로세스는 일반적으로 트리의 루트 노드에서 시작하여 요청된 데이터의 값을 현재 노드에 저장된 키와 비교합니다.

요청된 데이터가 키 값보다 작으면 현재 노드의 왼쪽 하위 노드에서 검색이 계속됩니다. 

요청된 데이터가 키 값보다 크면 현재 노드의 오른쪽 자식에서 검색을 계속합니다. 

이 프로세스는 요청된 데이터를 찾거나 트리에 데이터가 없다고 판단될 때까지 재귀적으로 반복됩니다.

B-tree에서는 각 노드에 자식 수가 많기 때문에 검색 프로세스가 더 빨라질 수 있으며, 데이터를 더 효율적으로 저장할 수 있습니다.

<aside>
💡 B-트리 구성은 아래에서 시작하여 위쪽으로 트리를 구성하는 상향식 접근 방식입니다.

</aside>