# MySQL 아키텍처

태그: MySQL, RDB
Date: September 9, 2023 7:00 PM
공개 여부: 공개
설명: MySQL 의 아키텍처 구성과 각 요소의 역할
카테고리: 데이터베이스

![Untitled](Untitled%2023.png)

# 엔진 구조

![Untitled](Untitled%2092.png)

MySQL 의 엔진 구조는 크게 실행 엔진과 스토리지 엔진이 존재한다.

각 엔진의 역할은 다음과 같다.

## MySQL 엔진

클라이언트로부터 접속, 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서, 전처리기, 옵티마이저 의 구성을 뜻한다.

**Query Parser**: 요청으로부터 받은 쿼리 문장을 토크나이징하여 트리 구조로 작성하며 이 과정에서 Syntax Error 를 발견한다.

**PreProcesssor**: 파서과정으로부터 받은 트리를 기반으로 구조적인 문제점을 확인한다. 존재하지않거나 권한 상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.

**Optimize**r: 쿼리 문장을 저렴한 비용으로 처리할 수 있도록 처리 및 결정한다.

## 스토리지 엔진(Handler)

요청된 SQL 문장을 분석/최적화 처리하고 실제 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어오는 부분을 전담한다.

MySQL 엔진은 하나지만 스토리지 엔진은 **여러 개를 동시에 사용**할 수 있다.

[**DB 인사이드 스토리지 엔진 by EXEM**](https://blog.ex-em.com/1680)

### Handler API

엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 각 스토리지 엔진에 읽기/쓰기 요청을 하는데 이러한 요청을 `**Handler 요청**`이라고 한다.

```sql
SHOW GLOBAL STATU SLIKE 'Handler%';
```

# MySQL 스레딩 구조

![Untitled](Untitled%2093.png)

MySQL 스레딩 구조는 포어그라운드 스레드와 백그라운드 스레드로 구분한다.

## Foreground Thread

MySQL 에 접속한 클라이언트 수만큼 존재하며 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 용도.

커넥션을 마치면 스레드 캐시로 돌아가고 **스레드 캐시에 충분한 양이 유지되면 파기된다.**

데이터를 데이터 버퍼나 캐시로부터 가져오며 두 영역모두 데이터가 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.

## Background Thread

InnoDB 백그라운드 스레드가 수행하는 처리의 예시이다.

- Insert Buffer 를 병합
- 로그를 디스크로 기록
- InnoDB 버퍼 풀의 데이터를 디스크에 기록
- 데이터를 버퍼로 읽어오기
- 잠금이나 데드락을 모니터링

일반적으로 대부분 DB는 쓰기 작업을 버퍼링하여 일괄 처리한다.

# 메모리 할당 및 사용 구조

![Untitled](Untitled%2094.png)

글로벌 메모리(Shared Memory) 영역은 모든 스레드에게 공유된다.

# InnoDB 스토리지 엔진 아키텍처

![Untitled](Untitled%2095.png)

## Primary 키에 의한 클러스터링

[8. 인덱스 (1) - Primary Key 클러스터링 인덱스](https://yelimkim98.tistory.com/59)

PK 에 의해 클러스터링 처리가 되기 때문에 데이터를 READ 할 때 좀 더 빨리 처리할 수 있게된다.

다만 WRITE 에서 성능적 손실을 보는데 자세한 내용은 위 링크를 참고하자.

## MVCC(Multi Version Concurrency Control)

**[InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)**

![Untitled](Untitled%2096.png)

변경된 내용을 버퍼에 반영하고 Undo Log 에 변경 전 내용을 유지하며

DB 의 격리수준에 따라 어떤 값을 읽어서 보여줄 지 결정한다.

UnDo 영역에 있는 백업 데이터는 필요로 하는 트랜잭션이 없다고 판단 될 경우 제거된다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 는 MVCC 기술을 사용하여 잠금을 걸지 않고 읽기 작업을 수행한다.

격리 수준이 `SERIALIZABLE` 이 아닌 `READ_UNCOMMITTED` 나 `READ_COMMITED`, `REPEATABLE_READ` 수준인 경우 I**NSERT와 연결되지 않은 순수한 읽기 작업은 다른 트랙잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행**된다.

변경되기 전 데이터를 읽기 위해 Undo 로그를 이용한다.

# 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금 대기 목록을 그래프 자료구조로 관리하며 주기적으로 데드락 요소를 검사한다.

데드락 요소를 발견하였을 때, 언두 로그양을 더 적게가진 트랜잭션을 강제 종료한다. ( 처리할 언두 양이 적기 때문 )

잠금의 갯수가 많아지면 데드락 감지 스레드가 느려지는데 퍼포먼스에 큰 이슈가 발생할 수 있다.

이러한 경우 데드락을 검사하지 않는 시스템 변수를 설정하는 것이 묘안이 될 수 있다.

<aside>
💡 다만, 이제 데드락이 발생한다면 중재되지 않기 때문에 무한정 대기를 하게 된다.

</aside>

위 문제를 해결하기 위해 `inno_db_lock_wait_timeout` 변수를 제공하며 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패되고 에러 메시지를 반환하게 된다.

# InnoDB Buffer Pool

스토리지 엔진에서 가장 핵심적인 부분으로 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간

일반적인 애플리케이션은 `INSERT`, `UPDATE`, `DELETE` 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 **랜덤 디스크 작업을 발생시킨다.**

**하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤 디스크 작업의 횟수를 감소시킬 수 있다.**

### 버퍼 풀의 구조

버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 스토리지 엔진이 필요로 할 때 해당 데이터 페이지를 읽어 각 조각에 저장한다.

버퍼 풀의 페이지 크기 조각을 관리하기 위해 크게 **`LRU 리스트`, `Flush 리스트`, `Free 리스트`라는 3개의 자료구조로 관리한다.**

프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않는 비어 있는 페이지 목록이며 새로운 사용자 쿼리가 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.

LRU 리스트 구조는 다음과 같다.

![Untitled](Untitled%2097.png)

엄밀히 따져 `LRU(Least Recently Used)`와 `MRU(Most Recently Used)` 가 결합된 구조이다.

목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다.

## Buffer Pool 과 redo log 의 관계

Inno DB 버퍼 풀은 메모리 서버 성능 향상을 위해 `데이터 캐시`와 `쓰기 버퍼링` 두 가지 용도가 존재한다.

버퍼 풀의 메모리 공간만 단순히 늘리는 것은 `데이터 캐시` 기능만 향상시키는 것 뿐이다.

버퍼 풀은 변경되지 않는 `클린 페이지`와 `INSERT`, `UPDATE`, `DELETE` 명령으로 변경된 데이터를 가진 `더티페이지`를 가진다.

리두 로그는 1개 이상의 고정 크기 파일을 연결하여 순환고리처럼 사용하며 데이터 변경이 발생하면 리두 로그 파일에 기록한다.

즉 **리두 로그에 대한 전체 파일 크기에 따라 쓰기 버퍼링의 성능을 제어**할 수 있는 것이다.

<aside>
💡 리두 로그는 체크포인트 개념으로 디스크 동기화(Write) 작업을 관리한다.

</aside>

## Buffer Pool Flush

더티 페이지가 특정 크기를 넘어가게되면 쓰기 폭증이 발생하기 때문에 성능에 악영향없이 디스크 동기화를 수행하기 위해 2개의 플러시 기능을 백그라운드 스레드가 처리한다.

- Flush list Flush
- LRU list Flush

### Flush list Flush

스토리지 엔진이 주기적으로 플러시 함수를 호출하여 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화한다.

<aside>
💡 이 때 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리가 부드럽게 처리된다.

</aside>

### LRU list Flush

사용 빈도가 낮은 데이터 페이지들을 읽어들여 더티 페이지는 디스크에 동기화, 클린 페이지는 즉시 프리 페이지로 옮기는 작업을 수행한다.

## Buffer Pool 상태 백업 및 복구

기본적으로 셧다운하고 재시작하면 쿼리 처리 성능이 1/10 도 안되는 경우가 발생한다.

버퍼 풀에 쿼리들이 사용할 데이터가 제거되었기 때문이다.

<aside>
💡 디스크 데이터가 버퍼 풀에 적재되어 있는 상태를 **`워밍 업(Warming Up)`** 이라고 한다.

</aside>

이러한 현상을 방지하기 위해 버퍼 풀 덤프 및 적재 기능을 활용하면 된다.

버퍼 풀 적재 내용은 `information_schema` DB의 `innodb_cached_indexes` 테이블을 확인하자.

# 슬로우 쿼리 로그

서버의 쿼리 튜닝은 크게 두 가지로 나뉜다.

- 서비스가 적용되기 전에 전체적으로 튜닝하는 경우
- 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝

서비스에서 사용 중인 경우 어떤 쿼리가 문제인 지 판단하는 데 슬로우 쿼리 로그가 도움이 된다.

`long_query_time` 시스템 변수에 설정한 값 이상만큼 소요된 시간의 쿼리는 모두 슬로우 쿼리로 취급되어 기록된다.

슬로우 쿼리의 작성 양식 중 `Lock_time` 은 실제 쿼리가 실행되는 데 필요한 잠금 체크와 같은 코드 실행 부분의 시간까지 모두 수행되기 때문에 **무조건 락이 있었다고 판단하긴 힘들다.**

<aside>
💡 매우 작은 값이면 무시하자

</aside>