---
tags:
  - test
  - java
  - spring
---

# 실패하는 테스트는 왜그런것일까

테스트 커버리지에만 너무 집착한다.
	테스트가 주는 이점을 활용할 생각보다는 커버리지에 집중하게 되어 의미가 무색해진다.

테스트가 주는 신호를 캐치하지 못한다. 즉.. 개선해야할 코드를 개선하지 못해서 테스트 구현이 어려워지는 것
	특정 코드에 너무 의존적인 부분을 테스트가 알려주기도 한다. (JPA, Spring 에 의존적인 코드라던 지..)

#### 강의 중 배우는 Tip
Java Switch 문은 JDK 12 부터 lambda 연산을 수행할 수 있다.

```java
long answer = switch (operator) {  
	case "+" -> num1 + num2;  
	case "-" -> num1 - num2;  
	case "*" -> num1 * num2;  
	case "/" -> num1 / num2;  
	default -> throw new InvalidOperationException();  
};
```

[Java 13 스위치](https://catch-me-java.tistory.com/31)
# TDD

테스트 주도 개발 즉 개발 이전에 테스트를 먼저 작성하는 것
1. RED - 깨지는 테스트를 먼저 작성한다.
2. GRREN - 깨지는 테스트를 성공시킨다.
3. BLUE - 리팩토링을 수행한다.

즉 GREEN 까지 도달했으므로 리팩토링을 수행한 이후에 잘못된 리팩토링인 지 바로 인지할 수 있다
개발자가 저지리는 대표적인 실수를 사전에 방지해준다는 이점이 존재한다.

TDD는 What/Who Cycle 을 주도할 수 있게 끔 도와준다.

> [!What/Who 사이클]
> 객체 사이의 협력 관계를 설계하기 위해서는 먼저 어떤 행위(What)를 수행할 것인지를 결정한 후에 누가(who) 그 행위를 수행할 것인지를 결정해야한다는 것이다.
> 여기서 어떤 행위가 바로 메시지다. - 객체지향의 사실과 오해 -

# 테스트와 SOLID 는 긴밀한 관계
## SRP
테스트는 명료하고 간단하게 작성해야하기 때문에 단일 책임 원칙을 지키게 됨
**테스트가 너무 많아져서 이게 무슨 목적의 클래스인 지 눈에 안들어오는** 지점이 생김
이 때가 클래스를 분할해야 하는 시점이므로 자연스럽게 책임이 분배 됨

## OCP
테스트 컴포넌트와 프로덕션 컴포넌트를 나누어 작업하게 되고 필요에 따라 해당 컴포넌트를 자유자재로 탈부착가능하게 됨

## LSP
이상적으로 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해줌

## ISP
테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경
불필요한 의존성을 실제로 확인할 수 있다.

## DIP
가짜 객체를 이용하여 테스트를 작성하려면 의존성이 역전되어 있어야 하는 경우가 생김

# 테스트의 3분류 
![[Pasted image 20231113174717.png]]

의미가 전체적으로 와닿지 않다면 대형(E2E), 중형(INTEGRATION), 소형(UNIT) 으로 구분해도 좋다.

## 소형 테스트(UNIT TEST)
단일 서버 / 단일 프로세스 / 단일 스레드에서 동작하는 테스트를 의미한다.
Disk I/O 나 Blocking call 이 있어서는 안된다.
> [!NOTE]
> Thread.sleep() 이 테스트 내에 존재하면 UNIT TEST 가 아닌 것이다.

소형 테스트는 항상 결과가 결정적이고 테스트 속도가 빨리지기 때문에 정말 중요하다.

## 중형 테스트(INTEGRATION TEST)
단일 서버내에서 동작하지만 멀티 프로세스와 멀티 스레드를 사용할 수 있다.

> [!NOTE]
> 즉, H2와 같은 테스트 디비를 사용할 수 있음

중형 테스트를 너무 많이 작성한 경우 테스트가 무거워지고 특정 환경에 의존적일 수 밖에 없게 된다.

## 대형 테스트(E2E)
멀티 서버를 사용할 수 있게 된다.

# 테스트 용어 개념 잡기
> [!NOTE]
> 구글링으로 각 내용 더 보강하기

## SUT(System Under Test)
테스트 하려는 대상을 의미한다.

## BDD(Behaviour Driven Development)
유저 스토리와 시나리오를 기반으로 테스트 코드를 작성한다.
( 어떠한 상황일 때 이 행동을하면 결과가 이렇다는 정의를 구조적으로 사용한다. )

## 상호작용 테스트(Interaction Test)
대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는 지 사용하는 기법

## 상태 기반 검증 & 행위 기반 검증

## 테스트 픽스처(Test Fixture)
테스트에 필요한 자원을 생성하는 것 

## 비욘세 규칙
"유지하고 싶은 상태나 정책이 있다면, 알아서 테스트를 만들어야 한다."

## Testability
테스트 가능성 즉 소프트웨어가 테스트 가능한 구조인 지 검토하는 것

## Test Double
로직 상 필요한 부분에 가짜 객체를 주입하여 (대역) 을 사용하는 것

### Stub
미리 준비된 값을 출력하는 객체 ( Mockito )

### Fake

### Mock
메소드 호출을 확인하기 이한 객체, 자기 검증 능력을 갖춤
사실상 Test Double 과 동일한 의미로 사용 됨

### Spy
메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

# 엔티티를 구분하자
## 도메인 엔티티
비즈니스에서 어떠한 문제를 해결하기 위해 만들어진 모델

## DB 엔티티
데이터베이스 분야에서 데이터베이스에 표현하려고 하는 유형, 무형의 객체

## 영속성 객체
현실세계의 문제를 해결하기 위해서 DB 엔티티를 도메인 엔티티로 옮겨야하는데 이것을 영속성 객체라고 칭하며
JPA + Hibernate 를 의미할 수도 있다.

# 테스트 조언

## private 메소드는 테스트하지 않아도 된다
private 메소드를 테스트하고 싶은 느낌이 든다면, 사실 private 메서드가 아니어야 하거나 다른 클래스로 분리/책임을 위임하여 public 으로 만들라는 신호다.
should I Test private method?

