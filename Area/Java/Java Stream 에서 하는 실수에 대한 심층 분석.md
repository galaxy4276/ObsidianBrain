---
tags: java-stream, java
---
# 스트림이 모든 시나리오에 적합하지는 않다.
스트림이 항상 최선의 선택이 아니라는 점을 인식하는 것이 중요합니다.
작업이 단순하거나 반복을 명시적으로 제어할 필요가 있는 경우 기존 루프가 더 적합할 수 있습니다.
예를 들어, 개발자가 단순히 목록을 반복하여 각 요소에 대해 간단한 작업을 수행하는 경우, `for` 또는 `forEach` 루프를 사용하는 것이 더 효율적이고 가독성이 높을 수 있습니다.

# 스트리밍 오버헤드: 크기가 중요한 경우
### 스트림 설정의 계산 비용
스트림 시작될 때마다 특정 계산 비용이 발생합니다.
이 비용에는 스트림의 내부 구조와 스트림에 적용되는 후속 작업의 설정 및 해체가 포함됩니다.
공장에서 생산 라인을 설치하는 것과 같이 작업을 시작하기 전에 모든 것을 제자리에 갖추는 데 시간과 리소스 비용이 내재되어 있다고 생각하면 됩니다.

### 오버헤드가 그만한 가치가 없는 경우
대규모 데이터 세트가 존재하는 경우는 스트림을 시작하는데 발생하는 오버헤드를 무시할 수 있겠지만,
5~10개가 존재하는 요소로 구성된 리스트를 작업하는 경우 스트림을 설정하는데 발생하는 오버헤드가 스트림의 기능적 장점보다 더 큰 단점을 발생시킬 수 있습니다.

예시는 다음과 같습니다.
```java
List<Integer> smallList = Arrays.asList(1, 2, 3, 4, 5);  
boolean containsNumber = smallList.stream().anyMatch(n -> n == 3);
```
위 작업은 간단한 루프나 리스트 내장 메서드를 활용하는 것이 좋습니다. (`contains`)

보통은 컬렉션 요소가 10개 미만의 요소인 경우 스트림은 과합니다.

# 단락 및 잘못 사용된 스트림과 연관성
## 단락이란?
스트림에서 단락 작업을 수행한다고 해서 스트림의 모든 요소가 반드시 처리되는 것은 아닙니다.
대신, 결과를 찾으면 처리를 중단하므로 스트림의 모든 요소를 검사하지 않아도 됩니다. 
원하는 결과를 얻기 위해 모든 데이터를 처리할 필요는 없으므로 특히 대규모 데이터 세트에서 성능 이점을 얻을 수 있습니다.

## 주요 단락 작업
### findFirst()
스트림에서 첫 번째 요소를 반환합니다.
병렬 스트림 컨텍스트에서는 스트림의 소스 또는 중간 연산에 의해 요소가 반환되는 순서에서 첫 번째 요소가 반환됩니다.
순차 스트림에서는 첫 번째 요소가 반환되지만 병렬 스트림에서는 어떤 청크가 먼저 처리되는 지에 따라 처리 중인 청크에서 첫 번째 요소를 반환할 수 있습니다.

###  anyMatch()
이 연산은 predicate(return bool) 를 받아서 주어진 predicate 와 요소가 일치하는 경우 참을 반환합니다.
핵심은 모든 요소를 검사하지 않는다는 것입니다.
predicate 와 하나라도 일치하는 요소가 발견되면 true 를 반환하고 더 이상의 처리를 하지 않습니다.

