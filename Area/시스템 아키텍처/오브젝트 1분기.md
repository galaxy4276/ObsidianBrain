#Book #Object #OOP
# 소프트웨어 모듈이란
> Robert C. Martin 이 Clean Architecture 에서 설명하는 내용

크기와 상관없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소
### 모듈 3원칙
*  실행 중 제대로 동작해야 한다.
* 변경을 위해 존재한다.
	>  대부분 모듈은 생명주기동안 변경되기 때문에, 간단한 작업만으로 변경이 가능해야 한다.
* 특별한 의사소통없이 개발자가 쉽게 읽고 이해해야한다.
	> 읽는 사람과 의사소통할 수 없는 코드는 개선해야 한다.
	

# 결합도 (coupling)
객체 사이의 의존성이 과한 경우를 가리킨다.
결합도를 낮춘다는 것은 한 객체가 스스로 책임지며 행할 수 있는 행동을 최대한 수용하는 것도 한 가지 방법일 듯 하다.
# 응집도 (Cohesion)
밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위힘하는 객체를 가리켜 응집도가 높다고 말한다.


> **와닿았던 설계의 의미**
> 설계란 코드를 배치하는 것이다.

# 도메인의 구조를 따르는 프로그램 구조
> 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 일컫음.

# 단순함도 객체로 표현하라
예를  들어, 금액(money) 을 Long 자료형으로 표현했을때보다 Money 라는 객체로 표현하는 것이
금액과 관련되어있다는 의미 전달이 명확해지기때문에 **도메인의 의미를 더 풍부하게 표현할 수 있다.**
> 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫 걸음이다.


# 컴파일 시간 의존성과 실행 시간 의존성
> 나에게 중요한 내용이다.

객체가 인터페이스에 의존하는 것에 대해 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다.
이것은 코드를 유연하고 쉽게 재사용할 수 있게끔 하며 확장 가능한 객체지향 설계를 가능케해준다.
하지만 **코드와 실행시점의 의존성이 다를수록 코드를 이해하기 어려워진다.**
유연한 설계가 매 번 정답이 아니라는 이야기다.
> 이러한 부분을 간과하고 있었다.

의존 객체가 힌트만이 존재한다면(인터페이스) 코드를 직접 찾아가서 확인해봐야하기 때문이다.
즉 **디버깅이 어려워진다.**

설계가 유연해질수록 코드를 이해하고 디버깅하기 어려워지며 반면 유연성을 억제하면 코드를 이해하고 디버깅하기 쉬워지지만 재사용성과 확장 가능성이 낮아진다는 사실을 기억하고 적절한 트레이드-오프를 수행하자.

# 상속에 대한 새로운 식견(나에게)
상속은 부모 클래스의 구현을 공유하며 행동이 다른 자식 클래스를 쉽게 추가할 수 있다.
이는 메서드 오바리이딩같은 개념을 활용해서 더욱 더 유용하게 사용할 수 있다.
이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을
**차이에 의한 프로그래밍(programming by difference)** 라고 한다.
상속은 안티-패턴이라는 이야기를 들었지만 결국 사용하기 나름이라는 점을 다시 회고하기 위해 작성한다.
> 자식 클래스가 부모 클래스를 대신하는 것을 **업캐스팅(upcasting)** 이라고 한다.

# 다형성
메시지와 메서드는 다른 개념이다.
메시지는 인스턴스에 전달되는 개념이고,
메서드는 객체에 상호작용하기 위해 연결된 객체의 실제 클래스가 무엇인가에 따라 실행 될 달라질 수 있다.
즉, 메시지는 늘 동일한 상호작용을 의미하지만 메서드는 어떤 것이 실행될 것인 지 메시지를 수신하는 객체의 클래스가 무엇이냐따라 달라지며 이를 **다형성**이라고 한다.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 하여금 컴파일 시간, 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.
> 쉽게 말해, 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

# 추상화의 힘
추상화를 사용할 경우 두 가지 장점을 보여준다.
1. 추상화의 계층만 떼어놓고 보면 요구사항의 정책을 높은 수준에서 서술가능하다.
2. 설계가 좀 더 유연해진다. ( 다형성을 누릴 수 있다. )
> 유연성이 필요한 곳에 추상화를 사용하라

# 68~69p 다시살펴보기
추상화 객체와 서브 클래스의 개념적 충돌을 인터페이스를 활용하여 해결할 수 있는 사례를 소개한다.
서브 클래스가 새로운 요구사항의 인터페이스를 구현하고 개념적 충돌이 발생하는 서브 클래스가 추상화 객체를 상속받지 않고 인터페이스를 구현함으로써 객체지향세계의 문제를 해결한다.

# 상속
상속의 문제점에 대해 서술한다.
### 가장 큰 문제점
캡슐화를 위반한다.
상속을 이용하기 위해서는 부모 클래스의 내부구조를 잘 알고 있어야한다.
부모 클래스의 구현이 자식 클래스에게 노출되며 부모 자식 간에 강하게 결합되도록 만들기 때문에 **부모 클래스를 변경할 때 자식 클래스도 함께 변경될 가능성이 높다.****
결과적으로 상속을 과도하게 사용한 코드는 변경도 어렵다.

**상속의 두 번째 단점은**
설계가 유연하지 않다는 것이다.
부모 자식 관계를 컴파일 시점에서 결정하기 때문에, 실행 시점에 따라 객체를 종류로 변경하는 것이 불가능하다.
이러한 부분을 유연하게 사용할 수 있는 방법이 바로 **합성**이다.

# 책임 주도 설계(RDD)
추후 정리해줘

# 객체와 역할
역할은 객체가 참여할 수 일종의 슬롯이다.
만약 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.
만약 여러 종류의 객체들이 협력에 참여할 수 있다면 역할이라고 부르면 된다.
단순히 한 종류만이 참여한다면 역할이 객체가 되기 때문이다.

      