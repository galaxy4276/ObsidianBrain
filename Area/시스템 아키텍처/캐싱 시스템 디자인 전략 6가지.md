---
tags: caching, architecture
---
# 캐싱 시스템 디자인 전략 6가지

태그: 캐싱
Date: September 7, 2023 12:37 AM
공개 여부: 공개
설명: 캐싱 시스템의 다양한 전략
카테고리: 인프라

# 캐싱 시스템 성능 지표

캐싱 시스템의 효율성과 성능을 개선하기 위해서는 다양한 지표를 모니터링하는 것이 매우 중요하며, 이를 바탕으로 캐싱 시스템과 관련된 중요한 비즈니스 결정을 내릴 수 있습니다.

### 캐시 적중률(Cache hit ratio)

요청 항목에서 캐시를 발견한 횟수의 비율 측정을 의미합니다.

캐시 적중률이 높을수록 캐시에서 더 많은 데이터가 제공되어 외부 저장소에 액세스할 필요성이 줄어들어 성능이 향상됩니다.

### 지연 시간(Latency)

캐시 데이터에 접근하는  걸리는 시간을 의미합니다.

지연 시간이 짧을 수록 캐시 데이터가 더 빨리 제공되어 전반적인 성능이 향상됩니다.

### 처리량(Throughput)

주어진 시간 규격 안에서 처리할 수 있는 데이터의 양을 의미합니다.

처리량이 높은 캐싱 시스템이 더 많은 요청을 처리할 수 있게 됩니다.

### 캐시 크기(Cache size)

캐시에 할당된 메모리 또는 저장 공간의 양입니다.

캐시 크기는 캐시 적중률과 누락률에 영향을 줄 수 있습니다.

클수록 적중률이 높아질 수 있지만 캐싱 솔루션의 비용과 복잡성이 증가할 수 있습니다.

### 캐시 누락률(Cache miss rate)

요청에서 캐시가 발견되지 않아 외부 저장소에서 데이터를 가져와야 하는 횟수의 비율을 의미합니다.

캐시 미스 비율이 높다는 것은 외부 저장소에서 더 많은 데이터를 가져와서 성능이 저하된다는 것을 의미합니다.

# 읽기 집약적인 애플리케이션에서의 캐식

워드프레스/정적 이미지 웹사이트/분석 헤비 서비스와 같은 읽기 집약적인 애플리케이션은 캐싱 시스템을 더 많은 읽기 캐시를 지원하는 방식으로 설계해야 합니다.

이에 대응해 다음과 같은 방법이 존재합니다.

- **Cache-aside**
- **Cache-through**
- **Refresh-ahead**

## Cache-aside

![Untitled](Untitled%20111.png)

가장 흔하게 사용되는 캐싱 시스템 전략입니다.

### 접근 방식

1. 애플리케이션에 요청이 들어올 때마다 먼저 캐시에서 요청된 데이터를 확인합니다.

2. 존재한다면 캐시는 데이터를 반환합니다.

3. 존재하지 않는다면 애플리케이션이 데이터베이스에서 데이터를 쿼리하고 돌아오는 도중에 캐시를 업데이트한 다음 데이터를 반환합니다.

### 장단점

캐시가 누락될 때마다 세 번의 트립이 발생하여 눈에 띄는 지연이 발생할 수 있습니다.

누군가가 캐시에 쓰지 않고 데이터베이스를 업데이트하면 데이터가 부실해질 수 있습니다.

<aside>
💡 따라서 캐시 어사이드는 일반적으로 다른 전략과 함께 사용됩니다.

</aside>

## Read-through

![Untitled](Untitled%20112.png)

캐시가 데이터베이스에 대한 가져오기/쿼리 호출을 수행한 다음 자체적으로 업데이트하여 요청된 데이터를 최종 사용자에게 반환합니다.

### 접근 방식

쿼리가 애플리케이션에 도달하면 애플리케이션은 캐시에서 데이터를 쿼리합니다.

데이터가 캐시에 없는 경우 캐시는 데이터베이스에서 데이터를 쿼리하고 자체적으로 갱신합니다.

캐시는 최종적으로 사용자에게 데이터를 반환합니다.

### 장단점

**애플리케이션 수준 코드 간소화:** 데이터 가져오기 로직이 캐시로 이동하여 애플리케이션 코드가 간소화됩니다.

읽기 확장성이 향상됩니다.

**Cache-aside** 방식에서 키가 만료되면 동시 요청이 데이터베이스에서 동일한 데이터를 여러 번 쿼리할 수 있습니다. 

**Read-Through** 방식에서는 캐시가 데이터베이스에 단 한 번의 쿼리만 전송되도록 합니다.

<aside>
💡 **Cache-aside 와 Read-Through 방식의 차이점**
두 방식의 차이점은 조회 대상의 주체에 존재합니다.
Cache-aside 는 애플리케이션이 조회하고 캐시에 저장하며,
Read-Through 는 캐시 시스템이 주체가 되어 시스템에서 자체적으로 외부 저장소를 조회하여 캐시에 보관해둡니다.

</aside>

## Refresh-ahead

![Untitled](Untitled%20113.png)

만료 시간 전에 캐시 데이터를 새로 고치는 전략으로, 가까운 시일 내에 요청될 것으로 예상되는 데이터를 새로고침합니다.

### 접근 방식

캐시된 데이터의 만료 시간이 60초이고 새로 고침 계수가 0.5라고 가정합니다.

60초 후에 캐시된 자원에 접근하면 캐시 시스템은 캐시 저장소에서 동기식 읽기를 수행하여 해당 값을 새로 고칩니다.

30초 후 캐시된 데이터에 액세스하면 캐시는 데이터를 반환하고 비동기적으로 데이터를 새로 고칩니다.

### 장단점

네트워크 지연 시간으로 인해 캐시 데이터를 갱신하는 데 시간이 걸릴 수 있지만, 캐시 데이터에 대한 요청이 매우 많은 시스템에서는 다수 요청에 대한 자원을 미리 갱신해두어 매우 효율적입니다.

# 쓰기 집약적 애플리케이션에서의 캐싱 방식

## Write-Through

![Untitled](Untitled%20114.png)

해당 전략은 캐시를 기본 데이터 저장소로 취급합니다. 

즉, 데이터가 먼저 캐시에서 갱신된 다음 데이터베이스에서 갱신됩니다.

### 장단점

**Read-Through** 방식과 함께 사용하면 데이터가 먼저 캐시에 읽기/쓰기되므로 캐시 무효화가 대부분 의미가 없어지므로 네트워크 호출에서 매우 효과적입니다.

모든 데이터가 새롭고 자주 액세스되는 데이터이고 데이터베이스에 대한 모든 쓰기도 캐시를 통해 이루어지기 때문에 데이터베이스와 캐시가 거의 일관성을 유지합니다.

## Write-behind

![Untitled](Untitled%20115.png)

이전 방식과 매우 유사하지만 데이터베이스 쓰기 호출이 비동기식이라는 점만 다릅니다.

### 장단점

쓰기 성능을 향상시킬 수 있으며, 대량의 쓰기 작업이 필요한 경우 이상적입니다.

가장 최근에 갱신되고 액세스된 데이터를 항상 캐시에서 사용할 수 있도록 보장하므로 **Read-Through**와 함께 사용할 경우 ***혼합 워크로드**에 적합합니다.

<aside>
💡 **혼합 워크로드(mixed workload)**
여러 종류의 작업이 동시에 발생하는 작업 부하를 의미

</aside>

배치 호출을 사용하는 경우 이러한 캐시는 데이터베이스에 대한 전체 쓰기를 줄여 부하를 줄이고 비용을 절감할 수 있습니다.

<aside>
💡 특히 데이터베이스 공급자가 요청 수에 따라 요금을 부과하는 경우(예: DynamoDB)에는 더욱 그렇습니다.

</aside>

단점으로 요청 빈도가 낮은 데이터도 캐시도 기록됩니다.

<aside>
💡 TTL 을 활용하여 이를 최소화할 수 있습니다.

</aside>

## Write-around

![Untitled](Untitled%20116.png)

데이터에 대한 DML 명령을 먼저 데이터베이스에 갱신한 다음 데이터베이스가 캐시를 비동기적으로 호출하여 키를 갱신합니다.

### 접근 방식

쓰기 요청이 발생하면 애플리케이션이 데이터베이스에 데이터를 기록합니다.

데이터베이스는 캐시에서 키를 비동기적으로 갱신/삭제합니다.

### 장단점

데이터를 한 번 쓰고 읽는 빈도가 낮거나 아예 읽지 않는 상황에서 우수한 성능을 제공합니다.

예를 들어 실시간 로그나 채팅방 메시지가 이에 해당합니다.

# 캐시 무효화 방법

캐시에서 오래된 데이터를 제거하여 가장 최신 데이터만 사용할 수 있도록 하는 프로세스입니다.

### 시간 기반 무효화(Time-based invalidation - TTL)

일정 시간이 지나면 캐시에 있는 데이터가 무효화됩니다.

이는 구현하기 쉬운 간단하고 효과적인 전략입니다.

그러나 일부 데이터는 다른 데이터보다 더 빨리 ***stale** 해질 수 있으므로 모든 사용 사례에 적합하지 않을 수 있습니다.

<aside>
💡 캐시에서 "stale"이란 용어는 캐시된 데이터가 더 이상 최신 상태가 아니라는 의미를 가집니다.

</aside>

### 이벤트 기반 무효화(Event-based invalidation)

기본 데이터 소스 변경 또는 기타 관련 이벤트와 같이 발생하는 특정 이벤트에 따라 캐시의 데이터가 무효화됩니다. 

이는 필요한 경우에만 데이터가 무효화되도록 하는 보다 타깃화된 무효화 접근 방식입니다.

### 버전 기반 무효화(Version-based invalidation)

캐시에 있는 각 데이터에 데이터가 변경될 때마다 증가하는 버전 번호가 할당됩니다.

데이터가 무효화되면 캐시에서 버전 번호가 업데이트되어 가장 최신 버전의 데이터만 사용되도록 합니다.

이 전략은 자주 변경되는 데이터에 효과적일 수 있지만 버전 번호를 관리하는 데 추가적인 오버헤드가 필요합니다.

### 가장 최근에 사용한 데이터 무효화(LRU)

캐시가 용량 제한에 도달하면 캐시에서 가장 최근에 사용된 데이터가 무효화됩니다.

이렇게 하면 가장 자주 사용되는 데이터가 캐시에 남아 오래된 데이터가 저장될 위험을 줄일 수 있습니다.

# References

****[6-Caching Strategies to Remember while designing Cache System](https://javascript.plainenglish.io/6-caching-strategies-to-remember-while-designing-cache-system-da058a3757cf)****

[https://crazy-horse.tistory.com/139#:~:text=1. Cache-Aside,-과정&text=데이터를 읽는 일이,데이터를 가져올 수 있다](https://crazy-horse.tistory.com/139#:~:text=1.%20Cache%2DAside,-%EA%B3%BC%EC%A0%95&text=%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC%20%EC%9D%BD%EB%8A%94%20%EC%9D%BC%EC%9D%B4,%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC%20%EA%B0%80%EC%A0%B8%EC%98%AC%20%EC%88%98%20%EC%9E%88%EB%8B%A4).

[캐시(Cache) 적용 패턴 및 관리 전략](https://luran.me/357)