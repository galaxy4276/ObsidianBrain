---
tags: architecture, event-loop, multi-threading, nodejs, nginx, interview
---
[이벤트 루프를 아세요?" 면접관의 질문](https://iorilan.medium.com/?source=post_page-----19d270a246c8--------------------------------)

# 서론

Apache 와 PHP 보다 왜 Nginx 와 Node.js 다 더 낫다고 합니다.
왜냐면 Nginx 와 Node.js 는 이벤트루프를 사용하는 구조이며 처리량 성능에서 더 두각을 나타내기 때문입니다.
그렇다면 이벤트 루프의 어떤 원리가 더 나은 처리량을 보여줄 수 있는 지 알아보겠습니다.


# 이벤트 루프가 아닌 다른 시나리오

![[Pasted image 20231106191926.png]]

Blocking I/O 를 제외한 다른 처리에 대해 설명하자면
#### 멀티 스레딩
모든 스레드가 서로 경쟁하기 때문에 신경써야하는 문제가 많습니다.
또한 특정 상황에서는 스레드로 병렬처리하는 것이 오히려 더 많은 연산과 시간을 요구합니다.

#### 멀티 스레딩 + GIL
멀티스레딩보다 더 나아보이지만 문제에 대한 "패치" 정도에 가깝습니다.

#### 코루틴
함수 통신 + 이벤트 루프(프로세스 내) 에다가 yield + send to 방식을 사용하여
비동기 처리를 수행하는 저렴하고 효율적인 솔루션이지만 단일 스레드에서는 병목 현상이 발생할 수 있습니다.

아래는 이벤트 루프를 사용하여 동일한 문제를 해결하는 구조도입니다.
![[Pasted image 20231106192306.png]]

중간에 게이트가 배치되어 다음과 같은 이점이 존재합니다.

* 분리된 흐름 - 데이터 수집과 처리를 분리하여 EV 를 사이에 두고 게이트가 주문 생성 및 발송에 집중하고 조리사는 음식 준비에 집중합니다.
* 요청이 대기열에 보관되고 Lazy 하게 처리됩니다.
  즉 메인 스레드를 차단하지 않으므로 애플리케이션의 전체 처리량이 향상됩니다.
* 확장가능성 - 요청에 대한 처리가 과부하로 느려질 경우 게이트를 추가함으로써 문제를 해결해나갈 수 있습니다.

# Node.js EV
![[Pasted image 20231106192544.png]]

* Node.js 의 EV 모델에서는 다양한 콜백 요청을 처리하기 위한 Phase 즉 대기열이 존재합니다.

> [!NOTE]
> Network I/O, Disk I/O, Timer, Close, ...

* HTTP 요청이 오면 네트워크 I/O 대기열에 추가되고 (I/O Poll Phase에서) 디스패칭 프로세스가 매우 빨라져서 I/O 가 차단되지 않습니다.

# Chrome 브라우저의 EV
![[Pasted image 20231106192829.png]]

각 크롬의 프로세스는 EV 를 통해 서로 커뮤니케이션합니다.

> [!NOTE]
> 이러한 부분은 MSA 시스템에서 메시지 큐를 통해 서로 커뮤니케이션하는 것과 동일한 구조입니다.

각 프로세스는 서로 다른 대기열로 메시지를 보냅니다.
즉 네트워크, UI, 타이머, 렌더링 대기열 등 각 대기열에서 요청을 처리하고 콜백 결과를 다시 전달합니다.

# OS 의 EV ( 단순화 모델 )
![[Pasted image 20231106193039.png]]

- 윈폼 애플리케이션이 시작되었습니다. 메인 스레드인 UI-Thread는 UI 요소 렌더링에 중점을 둡니다.
- 사용자가 버튼에 마우스를 클릭하면 윈폼 애플리케이션이 OS 메시지 대기열에 메시지를 '게시'하여 마우스(또는 키보드 이벤트)를 '구독'합니다.
- 나중에 마우스나 키보드와 같은 I/O 디바이스가 입력을 받은 후 데이터를 OS 메시지 큐에 게시하면 OS는 "구독자"(또는 옵저버)를 확인하고 해당 디바이스에 이벤트를 전송하는데, 이것이 바로 "콜백" 단계입니다.
- Windows 애플리케이션이 이벤트를 처리합니다.
- 위는 아이디어를 보여주기 위해 OS에서 메시지가 전송되는 과정을 단순화한 흐름입니다.
> [!NOTE]
> Android 또는 IOS와 같은 다른 운영 체제에도 메시지 대기열이 있습니다.

# Nginx 의 EV
![[Pasted image 20231106193219.png]]
nginx 는 서버가 시작되면 여러 워커 프로세스를 fork 합니다.
각 워커 프로세스는 epoll model 인 EV가 존재하며
다음은 워커 프로세스가 마스터 프로세스에 의해 fork 될 때 발생하는 과정입니다.

1. OS 가 Epoll Red-Black Tree 를 생성합니다.
2. 사용자 프로세스는 epoll API 를 호출하여 하나 이상의 소켓 파일 descriptor 를 R-B Tree 에 추가합니다.
   그 이후 새 데이터가 들어오는 지 대기 목록 큐를 수신합니다.
3. 네트워크 드라이버에서 HTTP 요청이 들어오는 경우 소켓 포트를 기반으로 파일 descriptor 를 찾아 대기열에 넣습니다.
4. 사용자 프로세스는 대기열에서 File Descriptor 정보가 포함된 메타 데이터를 가져옵니다.

어려운 내용이 많으므로 추가적으로 공부한 뒤 자세히 서술해두겠습니다.
