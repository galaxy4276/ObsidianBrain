---
tags: hashing, architecture
---
![Untitled](Untitled%20120.png)

# 일관된 해싱(Consistent Hashing)

클라이언트가 로드 밸런서에 요청을 보내면 로드 밸런서는 로드 밸런싱 알고리즘을 사용하여 서버 풀에 있는 서버 중 한 곳으로 요청을 라우팅합니다.

요청을 보낼 서버를 결정하는 데 사용할 수 있는 여러 가지 로드 밸런싱 알고리즘이 있습니다.

몇 가지 일반적인 알고리즘은 다음과 같습니다.

## 1. Round-Robin

로드 밸런서는 서버에 요청을 로테이션으로 전송하여 다음 요청을 리스트 중 다음 서버로 보냅니다

## 2. Least Connections(최소 연결)

로드 밸런서는 활성 연결 수가 가장 적은 서버로 요청을 보냅니다.

## 3. Least Response Time(최소 응답 시간)

로드 밸런서는 이전 요청에 대한 응답 시간이 가장 짧은 서버로 요청을 보냅니다.

## Weighted Round-Robin(가중치 라운드 로빈)

로드 밸런서가 서버에 로테이션 방식으로 요청을 보내지만 각 서버에 할당된 가중치에 따라 로테이션이 이루어집니다. 

가중치가 높은 서버는 더 많은 비율의 요청을 받습니다.

또한 로드 밸런서는 상태 확인을 사용하여 각 서버의 상태를 모니터링하고 요청을 정상 서버로만 라우팅할 수도 있습니다.

<aside>
💡 이렇게 하면 다운되었거나 문제가 있는 서버로 요청이 전송되지 않도록 할 수 있습니다.

</aside>

# Hash Function

로드밸런서는 해시 함수를 사용하여 이전에 연결했던 서버로 리다이렉션하기도 합니다.

해시 함수는 입력 값(키)를 받아 고정된 크기의 출력 값을 반환하는 수학적 함수입니다.

해시 함수는 사용자를 동일한 서버에 저장한 세션 상태 또는 캐시를 기반으로 더 나은 서비스를 제공할 수 있도록 연결하려는 경우에 유용합니다.

![이에 따라 사용자 A는 항상 서버 3에 연결됩니다.](Untitled%20121.png)

이에 따라 사용자 A는 항상 서버 3에 연결됩니다.

다른 사용자가 연결하면 로드 밸런서가 해시 값을 계산하여 해당 요청을 할당할 서버를 결정합니다. 동일한 사용자를 동일한 서버에 할당하는 것이 중요한데, 서버에 해당 사용자와 관련된 캐시 및 기타 사항을 저장해두면 더 나은 서버를 제공하는 데 도움이 될 수 있기 때문입니다.

이것은 좋아 보이지만 서버 풀에서 서버를 추가하고 제거할 때 문제가 발생합니다.

어떻게 문제가 되는지 이해해 봅시다.

![서버가 변경되면 해시 계산이 달라지고 그에 따라 서버가 할당됩니다.](Untitled%20122.png)

서버가 변경되면 해시 계산이 달라지고 그에 따라 서버가 할당됩니다.

부하 증가로 인해 새 서버를 추가하여 이제 트래픽을 처리할 서버가 5대가 되었다고 가정해 봅시다.

이제 문제는 사용자 A가 요청을 할 때 서버가 증가했기 때문에 완전히 다른 서버에서 처리하게 되고 해시 함수의 출력도 이전에는 4개의 서버를 고려하여 값을 계산했지만 이제는 5개의 서버가 있기 때문에 1번 서버에 연결을 시도하게 됩니다.

이러한 문제는 어떻게 해결할까요?

바로 **일관된 해싱(Consistent Hashing)** 을 사용하는 것입니다.

## Consistent Hashing 이란?

일관된 해싱은 키와 노드의 매핑을 크게 변경하지 않고도 해시 테이블에서 노드를 추가하거나 제거할 수 있는 해싱 기술입니다.

<aside>
💡 분산 해시 테이블(Distributed Hash Table) 또는 DHT라고도 합니다.

</aside>

일관된 해싱에서 가능한 모든 키의 집합을 `해시 공간(hash space)` 라고 합니다.

해시 공간은 일반적으로 원으로 표시되며 키는 원 주위에 고르게 분포되어 있습니다.

<aside>
💡 위와 같은 표현을  `해시 링(Hash Ring)` 이라고 합니다.

</aside>

![해시 공간의 범위는 0에서 n까지입니다(SHA-1 해시 함수를 사용하여 해시를 생성하는 경우 범위는 2¹⁶⁰ -1이 됩니다).](Untitled%20123.png)

해시 공간의 범위는 0에서 n까지입니다(SHA-1 해시 함수를 사용하여 해시를 생성하는 경우 범위는 2¹⁶⁰ -1이 됩니다).

해시 공간을 연결하고 고리처럼 반복되면 해시 링이라고 합니다.

![범위가 0에서 n까지인 해시 링](Untitled%20124.png)

범위가 0에서 n까지인 해시 링

![해시 공간을 표현하는 해시 링](Untitled%20125.png)

해시 공간을 표현하는 해시 링

분산 시스템의 각 노드에는 해시 링의 위치가 할당되며, 해시 링의 특정 범위에 속하는 키를 저장할 책임이 존재합니다.

노드가 담당하는 키의 범위를 `**영역(Zone)`** 이라고 합니다.

### 해시 함수를 사용하여 서버를 링에 매핑할 수 있습니다

![해시 함수를 사용하여 링에 매핑된 4개의 서버.](Untitled%20126.png)

해시 함수를 사용하여 링에 매핑된 4개의 서버.

이제 서버가 링에 매핑되었으니 이 서버에서 요청이 어떻게 처리되는지 이해해 보겠습니다.

![해시 함수를 사용하여 해시 공간에 매핑된 세 가지 요청이 있습니다.](Untitled%20127.png)

해시 함수를 사용하여 해시 공간에 매핑된 세 가지 요청이 있습니다.

각 요청은 시계 방향으로 이동하여 처음 만나는 서버에서 처리됩니다. 해시 함수에 따라 r1은 s4와 s1 사이의 링에 위치하므로 서버 s1이 r1을 처리하고, r2는 s2와 s1 사이의 링에 위치하므로 서버 s2가 r2를 처리하며, r3은 s4와 s3 사이의 링에 위치하므로 서버 s4가 r3을 처리합니다.

새로운 요청이 시스템에 삽입되면 해시 처리되어 특정 위치의 해시 링에 배치됩니다.

이제 서버를 추가하고 제거하면 어떻게 될까요?

### 새로운 서버의 추가

링에 새 서버를 추가하려면 앞서 설명한 대로 몇 개의 키만 다시 배포하면 됩니다.

새 서버를 추가하고 해시 함수를 기반으로 s3과 s4 사이의 링에 서버를 배치했다고 가정해 보겠습니다.

![해시 함수를 사용하여 링에 새 서버 추가하기](Untitled%20128.png)

해시 함수를 사용하여 링에 새 서버 추가하기

새 서버 s5를 추가하면 s3와 s4 사이의 링에 매핑됩니다. 

따라서 셔플해야 하는 요청은 r3뿐입니다. 따라서 이제부터 r3는 서버 s5가 처리합니다.

### 서버 제거

링에서 서버를 제거하려면 몇 개의 키만 다시 배포하면 됩니다.

![S1이 다운됨](Untitled%20129.png)

S1이 다운됨

s1이 다운되었다고 가정하면 재분배해야 하는 요청은 r1뿐입니다. 

시계 방향 접근 방식에 따라 r1은 서버 s2에서 처리됩니다.

서버가 추가되거나 제거될 때 요청이 대량으로 재분배되는 문제를 해결했기 때문에 이 방식은 좋아 보입니다. 

**하지만 이 접근 방식에도 몇 가지 문제가 있습니다.**

### 일관된 해싱 방식의 문제

- 해시 공간의 내부 데이터가 고르게 할당되어 있지 않습니다.
- 균일하지 않은 요청 배포

### 고르지 않은 해시 공간(Uneven hash space)

새로운 서버를 추가하고, 기존 서버를 제거할 수 있다는 점을 고려할 때 링의 각 해시 공간 크기를 모든 서버에 대해 동일하게 유지하는 것은 불가능합니다.

각 서버에 할당된 링의 해시 공간 크기가 매우 작거나 상당히 클 수 있습니다.

### 균일하지 않은 요청 배포(Non uniform request distribution)

대부분의 요청을 한 서버에 분배하고 다른 서버에는 요청을 거의(또는 전혀) 분배하지 않는 것을 의미합니다.

해시 함수가 대부분의 요청을 한 서버에서만 처리하도록 하는 결과를 초래할 수 있습니다.

각 서버에 할당된 링의 해시 공간 크기가 매우 작거나 상당히 클 수 있습니다.

그렇다면 이 두 가지 문제를 어떻게 해결할 수 있을까요?

**`가상 노드`**라는 기술을 사용하여 이 두 가지 문제를 해결할 수 있습니다.

## Virtual Node(가상 노드)

가상 노드는 실제 노드를 의미합니다. 

링에 있는 각 서버에는 여러 개의 가상 노드가 있습니다. 예를 들어 이해해 보겠습니다.

![가상 노드 3개가 있는 서버 1(가상 노드 1_1, 가상 노드 1_2, 가상 노드 1_3)](Untitled%20130.png)

가상 노드 3개가 있는 서버 1(가상 노드 1_1, 가상 노드 1_2, 가상 노드 1_3)

위 다이어그램에서 서버 1을 가리키는 3개의 가상 노드가 있으며, 이는 가상 노드에서 처리되는 모든 요청이 s1으로 리디렉션됨을 의미합니다.

<aside>
💡 서버는 더 많은 가상 노드를 가질 수 있으며 3은 임의의 숫자일 뿐입니다.

</aside>

이제 가상 노드에 따르면 요청 r3은 s5가 처리했던 것처럼 VN 1_2가 처리합니다.

가상 노드 수가 증가함에 따라 요청의 분배가 더욱 균형 있게 이루어집니다. 

가상 노드에 서로 다른 해시 함수를 사용하여 해시 링에 분산시킬 수 있습니다.

# 개인 정리

## 왜 사용하는 지?

많은 서버에 많은 데이터가 분산되어 있고, **사용 가능한 서버 수가 지속적으로 변경되는 경우** 사용한다.

기존 해싱 방식으로는 서버 개수가 추가되거나 제거될 때 모든 노드에 대해 해시를 다시 계산해야 하기 때문이다.

또한 키의 비균일 분포로 인해 한 쪽 서버에만 요청이 쏠릴 수도 있다.

## 가상 노드는 어떻게 배포를 더 균일하게 하는 지?

![Untitled](Untitled%20131.png)

하나의 머신(서버) 에 대해 복제 노드를 많이 많이 배치할 수록 위 사진과 같은 원리로 배포가 균일하게 되는 것임

# References

[Consistent Hashing](https://vishalrana9915.medium.com/consistent-hashing-36fa25892b4f)

[Consistent Hashing (일관된 해싱)](https://uiandwe.tistory.com/1325)